{"path":"downloaded/LocalGenerateModelLoader.java","javadoc":"","code":"@Override\n    public List<GenerateModel> load() {\n        try {\n            return new ObjectMapper().readValue(new File(path), new TypeReference<List<GenerateModel>>() {});\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }","method_name":"load"} {"path":"downloaded/loop_46.java","javadoc":"","code":"public static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint i,j,k;\n\t\tfor(i=1;i<=3;i++) {\n\t\t\tfor(j=1;j<=3;j++) {\n\t\t\t\tfor(k=1;k<=3;k++) {\n\t\t\t\t\tif(i!=j && j!=k && k!=i) {\n\t\t\t\t\tSystem.out.println(i+\"\"+j+\"\"+k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}","method_name":"main"} {"path":"downloaded/Unary.java","javadoc":"","code":"public String toString ()\n\t{\n\t\treturn \"not\";\n\t}","method_name":"toString"} {"path":"downloaded/Unary.java","javadoc":"","code":"public Unary clone()\n\t{\n\t\treturn new Unary();\n\t}","method_name":"clone"} {"path":"downloaded/MyGraph.java","javadoc":"/** \n     * Return the collection of vertices of this graph\n     * @return the vertices as a collection (which is anything iterable)\n     */","code":"public Collection<Vertex> vertices() {      \n        //return myGraph.keySet(); OLD\n        //create a copy of all the vertices in the map to restrict any reference\n        //to the interals of this class\n        Collection<Vertex> copyOfVertices = new ArrayList<Vertex>();\n        copyOfVertices.addAll(myGraph.keySet());\n        return copyOfVertices;\n    }","method_name":"vertices"} {"path":"downloaded/MyGraph.java","javadoc":"/** \n     * Return the collection of edges of this graph\n     * @return the edges as a collection (which is anything iterable)\n     */","code":"public Collection<Edge> edges() {\n        Collection<Collection<Edge>> copyOfEdges = new ArrayList<Collection<Edge>>();\n        //values = myGraph.values(); OLD\n        //create a copy of all the edges in the map to restrict any reference\n        //to interals of this class\n        copyOfEdges.addAll(myGraph.values());\n        Collection<Edge> allValues = new ArrayList<Edge>();\n        Iterator<Collection<Edge>> eachColl = copyOfEdges.iterator();\n        while(eachColl.hasNext()){\n            allValues.addAll(eachColl.next());\n        }\n\n        return allValues;\n    }","method_name":"edges"} {"path":"downloaded/MyGraph.java","javadoc":"/**\n     * Return a collection of vertices adjacent to a given vertex v.\n     *   i.e., the set of all vertices w where edges v -> w exist in the graph.\n     * Return an empty collection if there are no adjacent vertices.\n     * @param v one of the vertices in the graph\n     * @return an iterable collection of vertices adjacent to v in the graph\n     * @throws IllegalArgumentException if v does not exist.\n     */","code":"public Collection<Vertex> adjacentVertices(Vertex v) {\n        Vertex parameterVertex = new Vertex(v.getLabel());\n        if(!myGraph.containsKey(parameterVertex)){\n            throw new IllegalArgumentException(\"Vertex is not valid\");\n        }\n\n        //create a copy of the passed in vertex to restrict any reference\n        //to interals of this class\n        Collection<Vertex> adjVertices = new ArrayList<Vertex>();\n\n        Iterator<Edge> edges = myGraph.get(parameterVertex).iterator();\n        while(edges.hasNext()) {\n            adjVertices.add(edges.next().getDestination());\n        }\n        return adjVertices;\n    }","method_name":"adjacentVertices"} {"path":"downloaded/MyGraph.java","javadoc":"/**\n     * Test whether vertex b is adjacent to vertex a (i.e. a -> b) in a directed graph.\n     * Assumes that we do not have negative cost edges in the graph.\n     * @param a one vertex\n     * @param b another vertex\n     * @return cost of edge if there is a directed edge from a to b in the graph, \n     * return -1 otherwise.\n     * @throws IllegalArgumentException if a or b do not exist.\n     */","code":"public int edgeCost(Vertex a, Vertex b) {\n        if (!myGraph.containsKey(b) || !myGraph.containsKey(a)) {\n            throw new IllegalArgumentException(\"Vertex is not valid\");\n        }\n        int cost = -1;\n        if (adjacentVertices(a).contains(b)) {\n            //create a copy of all the edges at the passed in Vertex a\n            //to restrict any reference to interals of this class\n            Collection<Edge> copyOfEdges = new ArrayList<Edge>();\n            copyOfEdges.addAll(myGraph.get(a));\n\n            Iterator<Edge> edges = copyOfEdges.iterator();\n            while(edges.hasNext()){\n                Edge currEdge = edges.next();\n                if(currEdge.getDestination().equals(b)) {\n                    cost =  currEdge.getWeight();\n                }\n            }\n        }\n        return cost;\n    }","method_name":"edgeCost"} {"path":"downloaded/MyGraph.java","javadoc":"/**\n     * Returns the shortest path from a to b in the graph, or null if there is\n     * no such path.  Assumes all edge weights are nonnegative.\n     * Uses Dijkstra's algorithm.\n     * @param a the starting vertex\n     * @param b the destination vertex\n     * @return a Path where the vertices indicate the path from a to b in order\n     *   and contains a (first) and b (last) and the cost is the cost of \n     *   the path. Returns null if b is not reachable from a.\n     * @throws IllegalArgumentException if a or b does not exist.\n     */","code":"public Path shortestPath(Vertex a, Vertex b) {\n        // If a or b aren't present in the set of vertices throw an exception\n        if (!myGraph.containsKey(b) || !myGraph.containsKey(a)) {\n            throw new IllegalArgumentException(\"One of the vertices isn't valid\");\n        }\n        /* Create a map of Vertices to VertexInfos. Fill it with VertexInfos for all\n           vertices that each have no previous vertex and and a cost of INFINITY */\n        Map<Vertex, VertexInfo> vertInfos = new HashMap<Vertex, VertexInfo>();\n        for (Vertex v : vertices()) {\n            vertInfos.put(v, new VertexInfo(v, null, INFINITY));\n        }\n        /* Create a PriorityQueue for VertexInfos */\n        PriorityQueue<VertexInfo> viQueue = new PriorityQueue<VertexInfo>();\n        /* Create a VertexInfo for the start Vertex 'a' with a cost of 0. This uses a copy of Vertex a&b for immutability */\n        Vertex copyA = new Vertex(a.getLabel());\n        Vertex copyB = new Vertex(b.getLabel());\n\n        VertexInfo vi_a = new VertexInfo(copyA, null, 0);\n        /* Add VerxtexInfo for a to PQ and map it to it's VertexInfo */\n        viQueue.add(vi_a);\n        vertInfos.put(a, vi_a);\n        while(!viQueue.isEmpty()) {\n            /* Remove the VertexInfo with lowest cost */\n            Vertex curr = viQueue.poll().getVertex();\n            /* Check all adjacent Vertices of curr Vertex */\n            for (Vertex v : adjacentVertices(curr)) {\n                /* Calculate cost to get to v through curr */\n                int cost = vertInfos.get(curr).getCost() + edgeCost(curr, v);\n                /* If cost through curr is lower than previous */\n                if (cost < vertInfos.get(v).getCost()) {\n                    /* Remove v's VertexInfo from PQ */\n                    viQueue.remove(vertInfos.get(v));\n                    /* Overwrite previous value of v in map\n                       Add updated VerexInfo to PQ */\n                    VertexInfo vi = new VertexInfo(v, curr, cost);\n                    vertInfos.put(v,vi);\n                    viQueue.add(vi);\n                }\n            }\n        }\n        /* Create ArrayList for path */\n        List<Vertex> path = new ArrayList<Vertex>();\n        \n        /* Add each vertex and it's previous vertex to path until a null vertex is reached */\n        for (Vertex vert = copyB; vert != null; vert = vertInfos.get(vert).getPrev()) {\n            path.add(vert);\n        }\n\n        /* Reverse order of path */ \n        Collections.reverse(path);\n        /* Create new Path object with corresponding parameters */\n        if(path.contains(copyA)){\n            Path pathToB = new Path(path, vertInfos.get(copyB).getCost());\n            return pathToB;\n        } else {\n            return null;\n        }\n    }","method_name":"shortestPath"} {"path":"downloaded/MyGraph.java","javadoc":"","code":"public int compareTo(VertexInfo other) {\n            return this.cost - other.getCost();\n        }","method_name":"compareTo"} {"path":"downloaded/MyGraph.java","javadoc":"","code":"public Vertex getVertex() {\n            return curr;\n        }","method_name":"getVertex"} {"path":"downloaded/MyGraph.java","javadoc":"","code":"public Vertex getPrev() {\n            return prev;\n        }","method_name":"getPrev"} {"path":"downloaded/MyGraph.java","javadoc":"","code":"public int getCost() {\n            return cost;\n        }","method_name":"getCost"} {"path":"downloaded/EdgeOfTheDivinity.java","javadoc":"","code":"@Override\n    public EdgeOfTheDivinity copy() {\n        return new EdgeOfTheDivinity(this);\n    }","method_name":"copy"}