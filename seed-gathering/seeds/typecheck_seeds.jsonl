{"path":"downloaded/RandomMarkovChain.java","method_name":"extractAllowedTransitions","content":"/**\n\t * Gets an action to create a random Markov chain based on the specified parameters. <br>\n\t * <br>\n\t *\n\t * The {@code allowedTransitions} matrix has to have the following format, separated by ',':\n\t * <br>\n\t * <table>\n\t * <tr>\n\t * <td></td>\n\t * <td>INITIAL</td>\n\t * <td>foo</td>\n\t * <td>bar</td>\n\t * <td>$</td>\n\t * </tr>\n\t * <tr>\n\t * <td>INITIAL*</td>\n\t * <td>0</td>\n\t * <td>1</td>\n\t * <td>1</td>\n\t * <td>0</td>\n\t * </tr>\n\t * <tr>\n\t * <td>foo</td>\n\t * <td>0</td>\n\t * <td>1</td>\n\t * <td>0</td>\n\t * <td>1</td>\n\t * </tr>\n\t * <tr>\n\t * <td>bar</td>\n\t * <td>0</td>\n\t * <td>0</td>\n\t * <td>1</td>\n\t * <td>1</td>\n\t * </tr>\n\t * </table>\n\t *\n\t * @param allowedTransitionsFilePath\n\t *            Holds the allowed transitions from each state to each other (1=allowed, 0=not\n\t *            allowed).\n\t * @param averageThinkTimeMs\n\t *            The average think time to be used. Will be multiplied with a random factor between\n\t *            0.5 and 1.5 for each transition.\n\t * @param outputDataHolder\n\t *            The data holder that will hold the created Markov chain.\n\t * @return The action to be used for creating the Markov chain.\n\t */\nprivate int[][] extractAllowedTransitions(String[][] template) {\n\t\tint[][] allowedTransitions = new int[template.length - 1][template[0].length - 1];\n\n\t\tfor (int row = 0; row < allowedTransitions.length; row++) {\n\t\t\tfor (int col = 0; col < allowedTransitions[0].length; col++) {\n\t\t\t\tallowedTransitions[row][col] = Integer.parseInt(template[row + 1][col + 1]);\n\t\t\t}\n\t\t}\n\n\t\treturn allowedTransitions;\n\t}"}
{"path":"downloaded/Invoker.java","method_name":"isExpectedException","content":"/**\n   * @param ite The exception that was just thrown\n   * @param expectedExceptions The list of expected exceptions for this\n   * test method\n   * @return true if the exception that was just thrown is part of the\n   * expected exceptions\n   */\nprivate boolean isExpectedException(Throwable ite, Class<?>[] exceptions) {\n    if(null == exceptions) {\n      return false;\n    }\n\n    Class<?> realExceptionClass= ite.getClass();\n\n    for(int i= 0; i < exceptions.length; i++) {\n      if(exceptions[i].isAssignableFrom(realExceptionClass)) {\n        return true;\n      }\n    }\n\n    return false;\n  }"}
{"path":"downloaded/ConstantInfo.java","method_name":"hasPriority","content":"/**\n     * The index of this constant in the constant pool. Is -1 if the\n     * index has not yet been resolved. Constant pool indexes are resolved\n     * when the constant pool is written out.\n     */\nboolean hasPriority() {\n        return false;\n    }"}
{"path":"downloaded/ConstantInfo.java","method_name":"getEntryCount","content":"/**\n     * The index of this constant in the constant pool. Is -1 if the\n     * index has not yet been resolved. Constant pool indexes are resolved\n     * when the constant pool is written out.\n     */\nint getEntryCount() {\n        return 1;\n    }"}
{"path":"downloaded/ModelObject.java","method_name":"validateModel","content":"/**\n     *\n     */\npublic boolean validateModel(){\n        System.out.println(\"Validated!\");\n        return true;\n    }"}
{"path":"downloaded/HRServiceAppModuleImpl.java","method_name":"validateDepartment","content":"/**\n     * Container's getter for EmpDeptFkLink1.\n     * @return EmpDeptFkLink1\n     */\npublic String validateDepartment(){\n        \n        return \"continue\";\n    }"}
{"path":"downloaded/HRServiceAppModuleImpl.java","method_name":"testAction","content":"/**\n     * Container's getter for EmpDeptFkLink1.\n     * @return EmpDeptFkLink1\n     */\npublic String testAction(String arg){\n        \n        return \"continue\";\n    }"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getCollaborationRel","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getCollaborationRel(String viewname, String mainauth, String collabAuth, int start, int end) {\n\t\tString part1= \"SELECT a.author as author, coa.author as collabauth, COUNT(coa.author) as collabcnt FROM \" +\n\t\t\t\t\"dblp_author_ref_new a, dblp_author_ref_new coa, \"+ viewname + \" as p \" +\n\t\t\t\t\"WHERE a.id = coa.id AND a.id = p.id AND a.author != coa.author AND p.year >= \" + start + \" AND p.year <= \" + end;\n\t\tString part2=\"\";\n\t\tif (mainauth != null && !mainauth.equals(\"\")) {\n\t\t\tString str= \" AND a.author like \\\"\"+mainauth+\"\\\"\";\n\t\t\tif (collabAuth != null && !collabAuth.equals(\"\"))\n\t\t\t\tstr += \" AND coa.author like \\\"\"+collabAuth+\"\\\"\";\n\t\t\tpart2=str;\n\t\t}\n\t\tString coauthRelSQL= part1 + part2 + \" GROUP BY a.author, coa.author\";\n\t\treturn coauthRelSQL;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getCollabRelTableCreationSQL","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getCollabRelTableCreationSQL(String domainName) {\n\t\tString crCollabTableSQL = \"CREATE TABLE IF NOT EXISTS dblp_collab_\" +domainName +\n\t\t\"(author varchar(70) NOT NULL, \" +\n\t\t\" collabauth varchar(70) NOT NULL, \" + \n\t\t\" collabcnt int NOT NULL, \" +\n\t\t\" PRIMARY KEY (author,collabauth)) \";\n\t\treturn crCollabTableSQL;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getOldAuthorsInTimeSlice","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getOldAuthorsInTimeSlice(String viewname, int start, int end) {\n\t\tString sql = \"create table tmpt select ca from \" +\n\t\t\t\t\"(select distinct author as ca from dblp_author_ref_new a, \"+ viewname + \" as p \" +\n\t\t\t\t\"where a.id = p.id and p.year >= \" + start + \" and p.year <= \" + end + \") as currauths, \" +\n\t\t\t\t\"(select distinct author as pa from dblp_author_ref_new a, \"+ viewname + \" as p \" +\n\t\t\t\t\"where a.id = p.id and  p.year <= \" + (start -1) +\") as pastauths \" +\n\t\t\t\t\"where currauths.ca = pastauths.pa\";\n\t\treturn sql;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getOldOldCollaboration","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getOldOldCollaboration(String viewname, int start, int end) {\n\t\tString part1 = \"SELECT a.author as author, coa.author as collabauth, COUNT(*) as collabcnt \" +\n\t\t\t\t\"FROM dblp_author_ref_new a, dblp_author_ref_new coa, tmpt t1, tmpt t2, \" + viewname + \" as p \" +\n\t\t\t\t\"WHERE a.id = coa.id AND a.id = p.id AND a.author != coa.author AND a.author = t1.ca \" +\n\t\t\t\t\"AND coa.author = t2.ca AND p.year >= \" + start + \" AND p.year <= \" + end ;\n\t\t\n\t\tString coauthRelSQL= part1 + \" GROUP BY a.author, coa.author\";\n\t\treturn coauthRelSQL;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getTopicTableCreationSQL","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getTopicTableCreationSQL(String shortname) {\n\t\tString crTopicTableSQL = \"CREATE TABLE IF NOT EXISTS dblp_topic_\" +shortname +\n\t\t\"(tid varchar(50) NOT NULL, \" +\n\t\t\" keyword varchar(255) NOT NULL, \" + \n\t\t\" istop tinyint UNSIGNED ZEROFILL, \" + // Is this keyword a top keyword for this topic\n\t\t\" PRIMARY KEY (tid,keyword)) \";\n\t\treturn crTopicTableSQL;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getAuthKWRelTableCreationSQL","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getAuthKWRelTableCreationSQL(String shortname) {\n\t\tString crTopicTableSQL = \"CREATE TABLE IF NOT EXISTS dblp_authkw_\" +shortname +\n\t\t\"(author varchar(70) NOT NULL, \" +\n\t\t\" keyword varchar(255) NOT NULL, \" + \n\t\t\" PRIMARY KEY (keyword,author)) \";\n\t\treturn crTopicTableSQL;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getAuthCollabOverKWTableCreationSQL","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getAuthCollabOverKWTableCreationSQL(String shortname) {\n\t\tString crTopicTableSQL = \"CREATE TABLE IF NOT EXISTS dblp_authcollabkw_\" +shortname +\n\t\t\"(keyword varchar(255) NOT NULL, \" + \n\t\t\"author varchar(70) NOT NULL, \" + \n\t\t\" collabauth varchar(70) NOT NULL, \" +\n\t\t\"collabcnt int NOT NULL\" +\n\t\t\" ) \";\n\t\treturn crTopicTableSQL;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getTopicTableCreationSQLOld","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\n@Deprecated\n\tpublic static final String getTopicTableCreationSQLOld(String domainName) {\n\t\tString crTopicTableSQL = \"CREATE TABLE IF NOT EXISTS dblp_topic_\" +domainName +\n\t\t\"(tid varchar(50) NOT NULL, \" +\n\t\t\" topkw varchar(255) NOT NULL, \" + \n\t\t\" otherkw varchar(255), \" +\n\t\t\" PRIMARY KEY (tid)) \";\n\t\treturn crTopicTableSQL;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getDocTopicTableCreationSQL","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getDocTopicTableCreationSQL(String domainName) {\n\t\tString crTopicTableSQL = \"CREATE TABLE IF NOT EXISTS dblp_doctopic_\" +domainName +\n\t\t\"(id int(11) NOT NULL, \" +\n\t\t\" tid varchar(50) NOT NULL, \" + \n\t\t\" prob float NOT NULL, \" +\n\t\t\" PRIMARY KEY (id,tid)) \";\n\t\treturn crTopicTableSQL;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getAbstractTableCreationSQL","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getAbstractTableCreationSQL(String domainName) {\n\t\tString crTopicTableSQL = \"CREATE TABLE IF NOT EXISTS dblp_pub_abstracts_\" +domainName +\n\t\t\"(id int(8) NOT NULL COMMENT 'Maps to the id field db_pub_xxxx view', \" +\n\t\t\" redirected_url varchar(200) NOT NULL COMMENT 'Redirected URL from the ee field in the db_pub_xxxx view', \" +\n\t\t\"  abstract_content longtext COMMENT 'Abstract of this paper', \" + \n\t\t\"  PRIMARY KEY (id)) \";\n\t\treturn crTopicTableSQL;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getRawCitationRefTableCreationSQL","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getRawCitationRefTableCreationSQL(String domainName) {\n\t\tString crTopicTableSQL = \"CREATE TABLE IF NOT EXISTS mas_\" +domainName + \"_citation_reference_links \" +\n\t\t\"(id int(8) NOT NULL COMMENT 'Our internal database key in dblp_pub_new', \" +\n\t\t\" publication_title longtext NOT NULL, \" + \n\t\t\" citation_count int(10) NOT NULL DEFAULT '0', \" +\n\t\t\"citation_link varchar(300) DEFAULT NULL, \" +\n\t\t\" PRIMARY KEY (id)) \";\n\t\treturn crTopicTableSQL;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getRawCitationTableCreationSQL","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getRawCitationTableCreationSQL(String domainName) {\n\t\tString crTopicTableSQL = \"CREATE TABLE IF NOT EXISTS mas_\" +domainName + \"_pub_citations \" +\n\t\t\" ( citation_id int(8) NOT NULL AUTO_INCREMENT COMMENT 'Citation ID and primary Key', \" + \n\t\t\"  pub_id int(8) NOT NULL COMMENT 'ID of the publications refers to the key in dblp_pub_new', \" +\n\t\t\" pub_title longtext NOT NULL COMMENT 'Publication title whose citations are to be listed', \" +\n\t\t\" citation_title longtext NOT NULL COMMENT 'This paper has cited pub_title publication', \" +\n\t\t\" citation_title_year varchar(4) DEFAULT NULL COMMENT 'Year of publication of the Citation Title paper', \" +\n\t\t\" citation_authors longtext NOT NULL COMMENT 'Comma separated Authors in the citation paper', \" +\n\t\t\" PRIMARY KEY (citation_title(100),citation_id), \" +\n\t\t\" KEY `Index 2` (citation_id)\t)\";\t\n\t\treturn crTopicTableSQL;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getCitationMasterCreationSQL","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getCitationMasterCreationSQL(String domainName) {\n\t\tString crCiteTableSQL = \"CREATE TABLE IF NOT EXISTS dblp_citation_\" +domainName +\n\t\t\"(id int(8) NOT NULL, \" +\n\t\t\" citation_title longtext NOT NULL, \" + \n\t\t\" citation_year int(4) unsigned, \" +\n\t\t\" citation_authors longtext, \" +\n\t\t\" INDEX(id)) \";\n\t\treturn crCiteTableSQL;\n\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getRawCitationLoadSQL","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String[] getRawCitationLoadSQL(String domainName) {\n\t\tString [] res= new String[2];\n\t\tres[0] = \"SELECT pub_id, citation_title, citation_title_year, citation_authors\"  +\n\t\t\" FROM mas_\" + domainName + \"_pub_citations \";\n\t\tres[1] = \"INSERT INTO dblp_citation_\"+domainName+ \n\t\t\" (id, citation_title, citation_year, citation_authors) VALUES (?,?,?,?)\";\n\t\treturn res;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getTopicDistributionByPaperCount","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getTopicDistributionByPaperCount(String domainName, String shortname, int start, int end) {\n\t\tString pubrangeview = \"(SELECT id FROM \" + domainName + \" WHERE year >= \" + start + \" AND year <=\" + end + \")\"; \n\t\tString topicPaperCount = \"SELECT td.tid as tid, COUNT(p.id) as pcount FROM dblp_doctopic_\" + shortname + \" AS td LEFT JOIN \" +\n\t\tpubrangeview + \" AS p ON td.id = p.id GROUP BY td.tid\";\n/*\t\t\n\t\tString topicPaperCount = \"SELECT td.tid, COUNT(p.id) as pcount FROM dblp_doctopic_\" + shortname + \" AS td LEFT JOIN \" +\n\t\tpubrangeview + \" AS p ON td.id = p.id, dblp_topic_\" + shortname + \n\t\t\" AS t WHERE t.tid = td.tid GROUP BY td.tid\";\n*/\n\n\t\tString sql = \"SELECT tp.tid, t.keyword, tp.pcount FROM (\" + topicPaperCount + \") AS tp, dblp_topic_\"+shortname+ \n\t\t\" AS t WHERE t.tid = tp.tid AND t.istop = 1 order by tp.tid\";\n\t\treturn sql;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getTopicDistributionByCitationOld","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getTopicDistributionByCitationOld(String domainName, String shortname, int start, int end) {\n\t\tString pubrangeview = \"(SELECT p.id as id, count(*) as citationCount FROM dblp_ppr_cite c, \" + domainName + \n\t\t\" p WHERE p.id = c.paperid AND c.citationPaperId != -1 AND p.year >= \" + start + \" AND p.year <=\" + end +\n\t\t\" GROUP BY p.id )\" ;\n\t\tString topicCiteCount = \"SELECT td.tid as tid, SUM(pc.citationCount) as citationcount FROM dblp_doctopic_\" + shortname + \n\t\t\" AS td LEFT JOIN \" + pubrangeview + \" AS pc ON td.id = pc.id GROUP BY td.tid\";\n\n\t\tString sql = \"SELECT tp.tid, t.keyword, citationcount FROM (\" + topicCiteCount + \") AS tp, dblp_topic_\"+shortname+ \n\t\t\" AS t WHERE t.tid = tp.tid AND t.istop = 1 order by tp.tid\";\n\t\treturn sql;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getTopicDistributionByCitation","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getTopicDistributionByCitation(String domainName, String shortname, int start, int end) {\n\t\tString pubrangeview = \"(SELECT p.id as id, count(*) as citationCount FROM mas_se_pub_citations c, \" + domainName + \n\t\t\" p WHERE p.id = c.pub_id AND c.citation_title_year != '' AND p.year >= \" + start + \" AND p.year <=\" + end +\n\t\t\" GROUP BY p.id )\" ;\n\t\tString topicCiteCount = \"SELECT td.tid as tid, SUM(pc.citationCount) as citationcount FROM dblp_doctopic_\" + shortname + \n\t\t\" AS td LEFT JOIN \" + pubrangeview + \" AS pc ON td.id = pc.id GROUP BY td.tid\";\n\n\t\tString sql = \"SELECT tp.tid, t.keyword, citationcount FROM (\" + topicCiteCount + \") AS tp, dblp_topic_\"+shortname+ \n\t\t\" AS t WHERE t.tid = tp.tid AND t.istop = 1 order by tp.tid\";\n\t\treturn sql;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getTopicDistributionByCitationVariation","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getTopicDistributionByCitationVariation(String domainName, String shortname, int start, int end) {\n\t\tString pubrangeview = \"(SELECT c.id as id, count(*) as citationCount FROM dblp_citation_\" + shortname +\n\t\t\" c WHERE c.citation_year >= \" + start + \" AND c.citation_year <=\" + end +\n\t\t\" GROUP BY c.id )\" ;\n\t\tString topicCiteCount = \"SELECT td.tid as tid, SUM(pc.citationCount) as citationcount FROM dblp_doctopic_\" + shortname + \n\t\t\" AS td LEFT JOIN \" + pubrangeview + \" AS pc ON td.id = pc.id GROUP BY td.tid\";\n\n\t\tString sql = \"SELECT tp.tid, t.keyword, citationcount FROM (\" + topicCiteCount + \") AS tp, dblp_topic_\"+shortname+ \n\t\t\" AS t WHERE t.tid = tp.tid AND t.istop = 1 order by tp.tid\";\n\t\treturn sql;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getAuthorsGroupedByTopKW","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getAuthorsGroupedByTopKW(String domainName, String shortname, int start, int end) {\n\t\tString sql= \"SELECT DISTINCT a.author, t.keyword FROM dblp_author_ref_new a, dblp_topic_\"+shortname+\" t, dblp_doctopic_\"+shortname+\" td,\" +\n\t\tdomainName + \" p \" + \n\t\t\" WHERE a.id = td.id AND td.tid = t.tid AND a.id = p.id AND p.year >= \" + start + \" AND p.year <=\" + end  +\n\t\t\" AND t.istop = 1 ORDER BY t.keyword, a.author\";\n\t\treturn sql;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getAuthorTopicAffinityDistribution","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getAuthorTopicAffinityDistribution(String domainName, String shortname, int start, int end) {\n\t\tString sql= \"SELECT a.author as author, td.tid as tid, SUM(td.prob) as affinity FROM dblp_author_ref_new a, dblp_doctopic_\"+shortname+\" td,\" +\n\t\tdomainName + \" p \" + \n\t\t\" WHERE p.id = td.id AND a.id = p.id AND p.year >= \" + start + \" AND p.year <=\" + end  +\n\t\t\" GROUP BY a.author, td.tid ORDER BY author,tid\";\n\t\treturn sql;\n\t}"}
{"path":"downloaded/DNAAlphabetFactory.java","method_name":"hasEOS","content":"/**\n     * @param bval: The byte buffer.\n     * @param length: How many bytes in in bval to convert.\n     */\npublic boolean hasEOS() {\n\t    return false;\n\t  }"}
{"path":"downloaded/IncorrectUpdateSemanticsDataAccessException.java","method_name":"wasDataUpdated","content":"/**\n\t * Return whether data was updated.\n\t * If this method returns false, there's nothing to roll back.\n\t * <p>The default implementation always returns true.\n\t * This can be overridden in subclasses.\n\t */\npublic boolean wasDataUpdated() {\n\t\treturn true;\n\t}"}
{"path":"downloaded/Tema17.java","method_name":"c","content":"/**\n     * @param args the command line arguments\n     */\nprivate int c (int valorC) {\n        int valorDecrementado = valorC -1;\n        return valorDecrementado;\n    }"}
{"path":"downloaded/Reporter.java","method_name":"notNull","content":"/**\n   * Gibt einen Leerstring aus, falls der Text null ist.\n   * \n   * @param text\n   *          der Text.\n   * @return der Text oder Leerstring - niemals null.\n   */\npublic String notNull(String text)\n  {\n    return text == null ? \"\" : text;\n  }"}
{"path":"downloaded/Oracle4_RodCutting.java","method_name":"maxPrice","content":"/**\n\t * @param args\n\t */\nprivate static int maxPrice(int[] length, int[] price) \n\t{\n\t\tint[] val = new int[length.length+1];\n\t\tval[0] = 0;\n\t\t\n\t\tfor(int i=1; i<val.length; i++)\n\t\t{\n\t\t\tint maxval = Integer.MIN_VALUE;\n\t\t\tfor(int j=0; j<i; j++)\n\t\t\t{\n\t\t\t\tmaxval = Math.max(maxval, price[j] + val[i-j-1]);\n\t\t\t}\n\t\t\tval[i] = maxval;\n\t\t}\n\t\treturn val[val.length-1];\n\t}"}
{"path":"downloaded/AbstractPaletteEntryTest.java","method_name":"removeWhiteSpaces","content":"/**\n\t * Override or modify if wizard window title will be different. \n\t * @return\n\t */\nprotected String removeWhiteSpaces(String s) {\n\t\tboolean insideTag = false;\n\t\tboolean quota = false;\n\t\tint whitespaces = 0;\n\t\tboolean beginning = true;\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tchar c = s.charAt(i);\n\t\t\tif(!quota && Character.isWhitespace(c)) {\n\t\t\t\tif(!beginning) {\n\t\t\t\t\twhitespaces++;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!quota && c == '=' && insideTag) {\n\t\t\t\twhitespaces = 0;\n\t\t\t\tbeginning = true;\n\t\t\t}\n\t\t\tif(!quota && c == '<') {\n\t\t\t\tinsideTag = true;\n\t\t\t\twhitespaces = 0;\n\t\t\t}\n\t\t\tif(!quota && c == '>') {\n\t\t\t\tinsideTag = false;\n\t\t\t\tbeginning = true;\n\t\t\t} else if(!Character.isWhitespace(c)) {\n\t\t\t\tbeginning = false;\n\t\t\t}\n\t\t\tif(insideTag) {\n\t\t\t\tif(c == '\"') quota = !quota;\n\t\t\t\tif(quota) whitespaces = 0;\n\t\t\t}\n\t\t\tif(!quota && !Character.isWhitespace(c) && whitespaces > 0) {\n\t\t\t\tsb.append(' ');\n\t\t\t\twhitespaces = 0;\n\t\t\t}\n\t\t\tsb.append(c);\n\t\t}\n\t\treturn sb.toString();\n\t}"}
{"path":"downloaded/_936.java","method_name":"canReplace","content":"/**\n         * credit: https://leetcode.com/problems/stamping-the-sequence/discuss/201546/12ms-Java-Solution-Beats-100\n         * <p>\n         * Think reversely!\n         * How to change target to ****?!\n         */\nprivate boolean canReplace(char[] t, int i, char[] s) {\n            for (int j = 0; j < s.length; j++) {\n                if (t[i + j] != '*' && t[i + j] != s[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }"}
{"path":"downloaded/_936.java","method_name":"doReplace","content":"/**\n         * credit: https://leetcode.com/problems/stamping-the-sequence/discuss/201546/12ms-Java-Solution-Beats-100\n         * <p>\n         * Think reversely!\n         * How to change target to ****?!\n         */\nprivate int doReplace(char[] t, int i, char[] s, int stars) {\n            for (int j = 0; j < s.length; j++) {\n                if (t[i + j] != '*') {\n                    t[i + j] = '*';\n                    stars++;\n                }\n            }\n            return stars;\n        }"}
{"path":"downloaded/GetCharactersCharacterIdBookmarks200Ok.java","method_name":"toIndentedString","content":"/**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\nprivate String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }"}
{"path":"downloaded/Phylum.java","method_name":"getUsage","content":"/** {@inheritDoc} */\npublic String getUsage() {\n\t\treturn \"<inputDir> <outputDir>\";\n\t}"}
{"path":"downloaded/BigramHistogram.java","method_name":"removeNonAlphabeticCharactersFrom","content":"/**\n     * This method removes all non-alphabetic characters from a string\n     * O(n), where n is the amount of strings per line\n     * @param text\n     * @return\n     */\npublic static String removeNonAlphabeticCharactersFrom(String text) {\n\n        // replacing \\r\\n\\t for a single space\n        text = text.replaceAll(\"[\\\\p{Cntrl}]\", \" \");\n\n        // strips off all non-alphabetic character:[\\p{Lower}\\p{Upper}] apart from a blank\n        text = text.replaceAll(\"[^\\\\p{Alpha}\\\\p{Blank}]\", \" \");\n\n        // remove extra spaces\n        text = text.replaceAll(\"\\\\s+\", \" \");\n\n        return text.trim();\n    }"}
{"path":"downloaded/BlockPane.java","method_name":"isOpaqueCube","content":"/**\n\t * Is this block (a) opaque and (b) a full 1m cube? This determines whether or\n\t * not to render the shared face of two adjacent blocks and also whether the\n\t * player can attach torches, redstone wire, etc to this block.\n\t */\npublic boolean isOpaqueCube() {\n\t\treturn false;\n\t}"}
{"path":"downloaded/BlockPane.java","method_name":"renderAsNormalBlock","content":"/**\n\t * If this block doesn't render as an ordinary block it will return False\n\t * (examples: signs, buttons, stairs, etc)\n\t */\npublic boolean renderAsNormalBlock() {\n\t\treturn false;\n\t}"}
{"path":"downloaded/BlockPane.java","method_name":"getRenderType","content":"/**\n\t * The type of render function that is called for this block\n\t */\npublic int getRenderType() {\n\t\treturn 18;\n\t}"}
{"path":"downloaded/BlockPane.java","method_name":"canSilkHarvest","content":"/**\n\t * Return true if a player with Silk Touch can harvest this block directly, and\n\t * not its normal drops.\n\t */\nprotected boolean canSilkHarvest() {\n\t\treturn true;\n\t}"}
{"path":"downloaded/MapCell.java","method_name":"getMapPosition","content":"/**\n\t * Given a tuple representing the coordinates of the E-Puck on the\n\t * xz-plane, this method will estimate which cell the E-Puck is in and\n\t * return the row and column number of the estimated cell.\n\t * @param gpsCoord a a 1x3 array containing the x-coordinate, y-coordinate,\n\t * and z-coordinate of the E-Puck.  Only the 1st and 3rd value are dealt \n\t * with since the E-Puck does not change its y-coordinate in this simulation.\n\t * @return the estimated cell which corresponds to the coordinates given.\n\t * The position of the cell is notated by a row and column number.\n\t */\npublic int[] getMapPosition(double[] gpsCoord){\n\t\tint[] mapPosition = new int[2];\n\t\tmapPosition[0] = (int) Math.round(gpsCoord[0]*9);\n\t\tmapPosition[1] = (int) Math.round(gpsCoord[2]*9);\t\t\t\n\t\treturn mapPosition;\n\t}"}
{"path":"downloaded/Question6.java","method_name":"windowBanner","content":"/***********************************************************\n    *   Purpose: Create a banner string that can be used to \n    *           print the banner to a message dialog or the console\n    *           window\n    *   Interface:  no parameters\n    *   Returns:    no return\n    * **************************************************************/\npublic static String windowBanner(){\n        String bannerOut = \"\";\n        \n    \tbannerOut = \"*******************************************\\n\";\n    \tbannerOut += \"Name:\t\tyour name here\\n\";\n    \tbannerOut += \"Class:\t\tCS20S\\n\";\n    \tbannerOut += \"Assignment:\tAx Qy\\n\";\n    \tbannerOut += \"*******************************************\\n\\n\"; \n        \n        return bannerOut;\n    }"}
{"path":"downloaded/DiseaseController.java","method_name":"normalizeDiseaseId","content":"/**\n     * There is confusion about whether ORPHANET IDs should be coded as\n     * ORPHA:1234 or ORPHANET:1234. \n     *\n     * @param diseaseId\n     * @return\n     *\n     * returns ids in a normalized format, using ORPHA:1234\n     *\n     */\nprivate String normalizeDiseaseId(String diseaseId) {\n        String[] tokens = diseaseId.split(\":\");\n        if (\"ORPHANET\".equals(tokens[0])) {\n            diseaseId = \"ORPHA:\" + tokens[1];\n        }\n        return diseaseId;\n    }"}
{"path":"downloaded/MathDecisions.java","method_name":"findExpectedTotalVirtualSegments","content":"/**\n     * Computes total map footprint in bytes.\n     */\nstatic long findExpectedTotalVirtualSegments(long totalEntries,\n            int allocatedEntriesPerSegment) {\n        long totalVirtualSegments = 1;\n        while (true) {\n            double averageEntriesPerVirtualSegment = (double) totalEntries / totalVirtualSegments;\n            if (averageEntriesPerVirtualSegment <= allocatedEntriesPerSegment) {\n                return totalVirtualSegments;\n            }\n            totalVirtualSegments *= 2;\n        }\n    }"}
{"path":"downloaded/MathDecisions.java","method_name":"objectSizeRoundUp","content":"/**\n     * Computes total map footprint in bytes.\n     */\nstatic int objectSizeRoundUp(int size) {\n        return (size + 7) & ~7;\n    }"}
{"path":"downloaded/Common.java","method_name":"sub","content":"/**\n     * @param sum1\n     * @param sum2\n     */\npublic static double sub(double sum1, double sum2) {\n        return (sum1*10-sum2*10)/10;\n    }"}
{"path":"downloaded/SSReminderPrinter.java","method_name":"getTitle","content":"/**\n         * Gets the title for this report\n         *\n         * @return The title\n         */\npublic String getTitle() {\n            return null;\n        }"}
{"path":"downloaded/CreateDataHumPl.java","method_name":"timeForEvent","content":"/**\n     * Calculates the amount of smaples for one event in case of a planned simulation.\n     *\n     * @param simulationTime simulation time defined by the user\n     * @param amountEvents   amount of humidity rise/decrease\n     * @return time for one Event in seconds\n     */\nprivate static float timeForEvent(float simulationTime, int amountEvents) {\n        float humAmount = (amountEvents * 2) - 1;\n        float timeInMilli = simulationTime * 3600f;\n\n        return timeInMilli / humAmount;\n    }"}
{"path":"downloaded/RocketPerformance.java","method_name":"formatDouble","content":"/*************\n    * formatDouble method\n    *    -This method takes a double as a parameter and returns a double with two decimals.\n    *    @param   double to be truncated\n    *    @return  double that has been truncated\n    ****************/\nprivate double formatDouble(double number){\n      return Double.parseDouble(String.format(\"%.2f\", number));\n   }"}
{"path":"downloaded/Critter.java","method_name":"getcoor","content":"/**\n\t * A 25% chance to mutate once by calling the helper method, 6.25% to mutate\n\t * twice, etc.\n\t */\nprivate int[] getcoor(int direction) {\n\t\tint[] temp = new int[2];\n\t\tdirection = (direction % 6 + 6) % 6;\n\t\tswitch (direction) {\n\t\tcase 0:\n\t\t\ttemp[0] = 0;\n\t\t\ttemp[1] = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttemp[0] = 1;\n\t\t\ttemp[1] = 1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttemp[0] = 1;\n\t\t\ttemp[1] = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ttemp[0] = 0;\n\t\t\ttemp[1] = -1;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ttemp[0] = -1;\n\t\t\ttemp[1] = -1;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\ttemp[0] = -1;\n\t\t\ttemp[1] = 0;\n\t\t\tbreak;\n\t\t}\n\t\treturn temp;\n\t}"}
{"path":"downloaded/Day21.java","method_name":"countDigits","content":"/**\n     * Starting with a positive integer N, we reorder the digits in any order\n     * (including the original order) such that the leading digit is not zero.\n     * Return true if and only if we can do this in a way such that the resulting number is a power of 2.\n     * Note:\n     * 1 <= N <= 10^9\n     *\n     * @param N a positive integer\n     * @return true if and only if we can do this in a way such that the resulting number is a power of 2\n     */\npublic int[] countDigits(int N) {\n        int[] digits = new int[10];\n        while (N > 0) {\n            digits[N % 10]++;\n            N /= 10;\n        }\n        return digits;\n    }"}
{"path":"downloaded/Geodes.java","method_name":"escapeOql","content":"/**\n   * Replace single quote {@code '} with two quotes {@code ''}\n   *\n   * <p>From <a href=\"https://www.postgresql.org/docs/9.1/sql-syntax-lexical.html\">SQL syntax in PostgreSQL</a>:\n   *  <pre>\n   *    To include the escape character in the identifier literally, write it twice.\n   *  </pre>\n   * </p>\n   * @param oql string to escape\n   * @return escaped string\n   * @see\n   */\nstatic String escapeOql(CharSequence oql) {\n    return oql.toString().replace(\"'\", \"''\");\n  }"}
{"path":"downloaded/CocosHelper.java","method_name":"getSafeArea","content":"/**\n     * Battery receiver to getting battery level.\n     */\npublic static float[] getSafeArea() {\n        return new float[]{0, 0, 0, 0};\n    }"}
{"path":"downloaded/Use.java","method_name":"getDescription","content":"/**\n\t * Returns the purpose of the use command\n\t * \n\t * @return String of the purpose of the use command\n\t */\npublic String getDescription() {return \"Use an item in your inventory\"; }"}
{"path":"downloaded/EpaDataAgent.java","method_name":"getName","content":"/**\n\t * @param args\n\t */\npublic String getName() {\n\t\treturn \"Environmental Protection Agency\";\n\t}"}
{"path":"downloaded/EditDistanceProblem.java","method_name":"diff","content":"/**\n   * Return the the cost of the difference between the two characters.\n   *\n   * @param a The first character\n   * @param b The second character\n   */\npublic int diff(char a, char b) {\n    return (a == b ? 0 : 1);\n  }"}
{"path":"downloaded/ClassLoaderUtil.java","method_name":"getInnerClass","content":"/**\n     *Retrieves a given inner class definition from the specified outer class.\n     *@param cls the outer Class\n     *@param innerClassName the fully-qualified name of the inner class of interest\n     */\nprivate static Class getInnerClass(Class cls, String innerClassName) {\n        Class result = null;\n        Class[] innerClasses = cls.getDeclaredClasses();\n        for (Class c : innerClasses) {\n            if (c.getName().equals(innerClassName)) {\n                result = c;\n                break;\n            }\n        }\n        return result;\n    }"}
{"path":"downloaded/Oculta.java","method_name":"toBinary","content":"/**\n     * Toma un caracter(un numero en este caso) y lo transforma en su representacion\n     * en binario\n     * @param un byte que es el caractera a transformar.\n     * @return la representacion en cadena binaria.\n     */\nprivate String toBinary(byte caracter){\n        byte byteDeCaracter = (byte)caracter;\n        String binario=\"\";\n        for( int i = 7; i>=0; i--){\n            binario += ( ( ( byteDeCaracter & ( 1<<i ) ) > 0 ) ? \"1\" : \"0\" ) ;\n        }\n        return binario;\n    }"}
{"path":"downloaded/Oculta.java","method_name":"formato","content":"/**\n     * Toma una cadena con espacios y la regresa completa, rellena de ceros \n     * @param una cadena en \"binario\".\n     * @return la misma cadena pero rellena de ceros.\n     */\nprivate String formato(String cadena){\n        cadena = cadena.replaceAll(\" \",\"0\");\n        return cadena;\n    }"}
{"path":"downloaded/EventActionInfo.java","method_name":"validate","content":"/**\n      * Title: validate\n      * Description: Description of the method\n      * \n      */\npublic boolean validate() throws Exception {\n        return true;\n    }"}
{"path":"downloaded/Lcm.java","method_name":"calculateGCD","content":"/**\n\t * LCM (a,b) = (axb)/GCD(a,b)\n\t *  \n\t * @param a\n\t * @param b\n\t * @return LCM of a & b. For e.g. GCD(12,15)=60\n\t */\nprivate static int calculateGCD(int a, int b){\n\t\tif(b==0){\n\t\t\treturn a;\n\t\t}else{\n\t\t\tint r = a%b;\n\t\t    return calculateGCD(b, r);\n\t\t}\n\t}"}
{"path":"downloaded/ArrayListIterator.java","method_name":"toString","content":"/**\n\t * Construct a list iterator for the specified array, starting at the\n\t * specified start index and continuing for the specified length.\n\t *\n\t * @param array\n\t *            the array\n\t * @param start\n\t *            the start\n\t * @param length\n\t *            the length\n\t */\n@Override\n\tpublic String toString() {\n\t\treturn super.toString();\n\t}"}
{"path":"downloaded/AppOps.java","method_name":"formatTitle","content":"/**\n     * Format the title of the quiz before it can be joined with author name to\n     * form the id. Take away the space That is inside the string and replace\n     * it with underscore and if there is an underscore replace with a space.\n     *\n     * @param title\n     * @return String\n     */\npublic static String formatTitle(String title)\n    {\n        char[] temp = title.trim().toCharArray();\n        int count = 0;\n        for (char c : temp) {\n            if (c == ' ') {\n                temp[count] = '_';\n            } else if (c == '_') {\n                temp[count] = ' ';\n            }\n            count++;\n        }\n        \n        return String.valueOf(temp);\n        \n    }"}
{"path":"downloaded/AppOps.java","method_name":"verifyEntry","content":"/**\n     * Return a specific entity object Quiz or KeywordUser\n     *\n     * @param type\n     * @return String\n     */\npublic static String verifyEntry(String sentence, String keys){\n        String isVerified = \"success\";\n        String delimeter = \"\\\\s|,|\\\\.\";\n        String[] splitSentence = sentence.split(\" \");\n        \n        for (String key : keys.split(delimeter))\n        {\n            for(String element : splitSentence)\n            {\n                if(!element.equals( key.trim() ))\n                {\n                    isVerified =  \" The key \" + key + \" doesn't match any word in the corresponding sentence\";\n                    return isVerified ;\n                }\n            }\n            if (sentence.equals(\"\") || key.equals(\"\"))\n            {\n                isVerified =  \"Sentence and keys cannot be left empty\";\n                return isVerified ;\n            }\n        }\n        \n        System.out.println(\"verified is about leave and isverified is..: \"+isVerified);\n        \n        return isVerified;\n    }"}
{"path":"downloaded/FieldVerifier.java","method_name":"isValidName","content":"/**\n\t * Verifies that the specified name is valid for our service.\n\t * \n\t * In this example, we only require that the name is at least four characters. In your application, you can use more\n\t * complex checks to ensure that usernames, passwords, email addresses, URLs, and other fields have the proper\n\t * syntax.\n\t * \n\t * @param name\n\t *           the name to validate\n\t * @return true if valid, false if invalid\n\t */\npublic static boolean isValidName(String name) {\n\t\tif (name == null) {\n\t\t\treturn false;\n\t\t}\n\t\treturn name.length() > 3;\n\t}"}
{"path":"downloaded/JwtRequestFilter.java","method_name":"extractFromAuthorization","content":"/**\n     * Instantiates a new Jwt request filter.\n     *\n     * @param jwtTokenUtil the jwt token util\n     * @param authService  the auth service\n     */\nprivate String extractFromAuthorization(String str) {\n        if (str != null && str.startsWith(\"Bearer \")) {\n            return str.substring(7);\n        }\n        return \"\";\n    }"}
{"path":"downloaded/JwtRequestFilter.java","method_name":"extractFromCookie","content":"/**\n     * Instantiates a new Jwt request filter.\n     *\n     * @param jwtTokenUtil the jwt token util\n     * @param authService  the auth service\n     */\nprivate String extractFromCookie(String str) {\n        String token = \"\";\n        if (str != null) {\n            int pos = str.indexOf(\"token=\");\n            if (pos >= 0) {\n                token = str.substring(pos + 6);\n                pos = token.indexOf(';');\n                if (pos >= 0) {\n                    token = token.substring(0, pos);\n                }\n            }\n        }\n        return token;\n    }"}
{"path":"downloaded/Miscellaneous.java","method_name":"addBinaryNumbers","content":"/**\n\t * Returns the binary sum of two binary numbers represented as strings.\n\t * Space: O(n)\n\t * Time: O(n) where n is the length of the longer string.\n\t * @param num1 binary number represented as a string.\n\t * @param num2 binary number represented as a string.\n\t * @return the binary sum of two binary numbers represented as strings.\n\t */\npublic static String addBinaryNumbers(String num1, String num2) {\n\t\tif (num1 == null || num2 == null)\n\t\t\treturn null;\n\t\t\n\t\tint index1 = num1.length() - 1;\n\t\tint index2 = num2.length() - 1;\n\t\tboolean carry = false;\n\t\tString result = \"\";\n\t\t\n\t\twhile(index1 >= 0 && index2 >= 0) {\n\t\t\tint sum = Integer.parseInt(num1.substring(index1, index1 + 1)) + Integer.parseInt(num2.substring(index2, index2 + 1));\n\t\t\tif (sum == 0) {\n\t\t\t\tif (carry) {\n\t\t\t\t\tresult += '1';\n\t\t\t\t\tcarry = false;\n\t\t\t\t} else\n\t\t\t\t\tresult += '0';\n\t\t\t} else if (sum == 1) {\n\t\t\t\tif (carry)\n\t\t\t\t\tresult += '0';\n\t\t\t\telse\n\t\t\t\t\tresult += '1';\n\t\t\t} else { // sum == 2\n\t\t\t\tif (carry)\n\t\t\t\t\tresult += '1';\n\t\t\t\telse {\n\t\t\t\t\tresult += '0';\n\t\t\t\t\tcarry = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tindex1--;\n\t\t\tindex2--;\n\t\t}\n\t\t\n\t\twhile(index1 >= 0) {\n\t\t\tif (num1.charAt(index1) == '0') {\n\t\t\t\tif (carry) {\n\t\t\t\t\tresult += '1';\n\t\t\t\t\tcarry = false;\n\t\t\t\t} else\n\t\t\t\t\tresult += '0';\n\t\t\t} else { // num1.charAt(index1) == '1'\n\t\t\t\tif (carry)\n\t\t\t\t\tresult += '0';\n\t\t\t\telse\n\t\t\t\t\tresult += '1';\n\t\t\t}\n\t\t\t\n\t\t\tindex1--;\n\t\t}\n\t\t\n\t\twhile(index2 >= 0) {\n\t\t\tif (num2.charAt(index2) == '0') {\n\t\t\t\tif (carry) {\n\t\t\t\t\tresult += '1';\n\t\t\t\t\tcarry = false;\n\t\t\t\t} else\n\t\t\t\t\tresult += '0';\n\t\t\t} else { // num2.charAt(index2) == '1'\n\t\t\t\tif (carry)\n\t\t\t\t\tresult += '0';\n\t\t\t\telse\n\t\t\t\t\tresult += '1';\n\t\t\t}\n\t\t\t\n\t\t\tindex2--;\n\t\t}\n\t\t\n\t\tif (carry)\n\t\t\tresult += '1';\n\t\t\n\t\t// reverse result string\n\t\tString reverseResult = \"\";\n\t\tfor (int i = result.length() - 1; i >= 0; i--)\n\t\t\treverseResult += result.charAt(i);\n\t\t\n\t\treturn reverseResult;\n\t}"}
{"path":"downloaded/MillGui.java","method_name":"locationToIndex","content":"/**\n\t * Returns the new state of the mill board.\n\t * @return String: new state\n\t */\npublic int locationToIndex(char row, char col) {\n\t\t\n\t\tint index = 0;\n\t\tint p1 = 0; //row\n\t\tint p2 = 0; //col\n\t\tint p3 = 0; // if col == 1 2 3 \n\t\t\n\t\tswitch (row) {\n\t\tcase 'A': \n\t\t\tp1 = 1;\n\t\t\tbreak;\n\t\tcase 'B':\n\t\t\tp1 = 2;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tp1 = 3;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tp1 = 4;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tp1 = 5;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\tp1 = 6;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tswitch (col) {\n\t\tcase '7':\n\t\t\tp2 = 0;\n\t\t\tbreak;\n\t\tcase '6':\n\t\t\tp2 = 1;\n\t\t\tbreak;\n\t\tcase '5':\n\t\t\tp2 = 2;\n\t\t\tbreak;\n\t\tcase '4':\n\t\t\tp2 = 3;\n\t\t\tbreak;\n\t\tcase '3':\n\t\t\tp2 = 4;\n\t\t\tp3 = 3;\n\t\t\tbreak;\n\t\tcase '2':\n\t\t\tp2 = 5;\n\t\t\tp3 = 3;\n\t\t\tbreak;\n\t\tcase '1':\n\t\t\tp2 = 6;\n\t\t\tp3 = 3;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t\treturn (p1 + (p2*3) + p3) - 1;\n\t\t\n\t}"}
{"path":"downloaded/_EntityAddress.java","method_name":"hasPrimaryKey","content":"/** The kind of relationship the address has with the entity */\npublic static boolean hasPrimaryKey() { return false; }"}
{"path":"downloaded/TransplantDriver.java","method_name":"formatString","content":"/**\n     * A helper method that formats String inputs by ensuring that it follows proper capitalization.\n     * @param str The String inputs that need to be formatted.\n     * @return The formatted String.\n     */\npublic static String formatString(String str){\n        String[] arr = str.split(\" \");\n        String resultant = \"\";\n        for(int i = 0; i < arr.length;i++){\n            if(arr[i].length() == 1)\n                arr[i] = arr[i].toUpperCase();\n            else if(arr[i].length() == 0)\n                continue;\n            else{\n                arr[i] = Character.toUpperCase(arr[i].charAt(0)) + arr[i].substring(1);\n            }\n        }\n        for(String s : arr)\n            resultant += s + \" \";\n        return resultant.trim();\n    }"}
{"path":"downloaded/OkapiBM25.java","method_name":"toString","content":"/**\n     * Returns a score for a single term in the document.\n     *\n     * @param stats     Provides access to corpus-level statistics\n     * @param termFreq\n     * @param docLength\n     */\n@Override\n    public String toString() {\n        return \"Okapi BM25\";\n    }"}
{"path":"downloaded/SecurityLabel.java","method_name":"hashCode","content":"/** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */\n@Override\n  public int hashCode() {\n    return 0;\n  }"}
{"path":"downloaded/BranchVersionNumerationAdapter.java","method_name":"buildVersionName","content":"/**\n\t * Build version name\n\t */\nprivate String buildVersionName(String versionNumber) {\n\t\tString ver[] = versionNumber.split(\"\\\\.\");\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\tif (ver.length > 1) {\n\t\t\tint verNum = Integer.parseInt(ver[ver.length - 1]);\n\t\t\t\n\t\t\tfor (int i=0; i<ver.length - 1; i++) {\n\t\t\t\tsb.append(ver[i]).append(\".\");\n\t\t\t}\n\t\t\t\n\t\t\treturn sb.toString() + ++verNum;\n\t\t} else {\n\t\t\tint verNum = Integer.parseInt(versionNumber);\n\t\t\treturn Integer.toString(++verNum);\n\t\t}\n\t}"}
{"path":"downloaded/YearSiteNumAccessionValidator.java","method_name":"getYearStartIndex","content":"/**\n\t * @param accessionNumber\n\t * @param recordType\n\t * @return\n\t */\nprotected static int getYearStartIndex() {\n\t\treturn 0;\n\t}"}
{"path":"downloaded/VectorHeapb.java","method_name":"left","content":"/**\n\t * @param i\n\t * @return\n\t */\nprotected static int left(int i)\n\t// pre: 0 <= i < size\n\t// post: returns index of left child of node at location i\n\t{\n\t\treturn 2 * i + 1;\n\t}"}
{"path":"downloaded/VectorHeapb.java","method_name":"parent","content":"/**\n\t * @param i\n\t * @return\n\t */\nprotected static int parent(int i)\n\t// pre: 0 <= i < size\n\t// post: returns parent of node at location i\n\t{\n\t\treturn (i - 1) / 2;\n\t}"}
{"path":"downloaded/VectorHeapb.java","method_name":"right","content":"/**\n\t * @param i\n\t * @return\n\t */\nprotected static int right(int i)\n\t// pre: 0 <= i < size\n\t// post: returns index of right child of node at location i\n\t{\n\t\treturn (2 * i + 1) + 1;\n\t}"}
{"path":"downloaded/VectorHeapb.java","method_name":"toString","content":"/**\n\t * @param root\n\t */\n@Override\n\tpublic String toString() {\n\t\treturn \"\";\n\t}"}
{"path":"downloaded/HtmlFormCredential.java","method_name":"isEveryTime","content":"/**\n     * @param context ProcessorURI context to use.\n     * @return Form inputs as convenient map.  Returns null if no form items.\n     * @throws AttributeNotFoundException\n     */\npublic boolean isEveryTime() {\n        // This authentication is one time only.\n        return false;\n    }"}
{"path":"downloaded/Kernels2D.java","method_name":"normalize","content":"/**\n     * Normalizes the given kernel such that the values sum up to 1\n     * \n     * @param data\n     *            the kernel data in Z-XY order\n     * @return\n     */\nprivate static double[] normalize(double[] data)\n    {\n        double sum = 0;\n        \n        for (double d : data)\n            sum += d;\n        \n        if (sum != 1 && sum != 0)\n        {\n            for (int i = 0; i < data.length; i++)\n                data[i] /= sum;\n        }\n        \n        return data;\n    }"}
{"path":"downloaded/CountingSort.java","method_name":"sort","content":"/**\n     * @param input integer array given as input\n     * @param k     defines maximum integer value in input; all integers must in range [0..k]\n     * @return input array is sorted in a stable (!!) manner\n     */\npublic static Integer[] sort(Integer[] input, Integer k) {\n\n        Integer[] output = new Integer[input.length];    // array that will take sorted result.\n\n        // count how often each value occurs\n        int[] count = new int[k + 1];\n        for (Integer j : input) {\n            count[j]++;\n        }\n\n        // count in \"count[j]\" how many elements are <= j\n        for (int j = 1; j <= k; j++) {\n            count[j] = count[j] + count[j - 1];\n        }\n\n        // iterate over input, put each element into correct position of result array\n        // using the computed cumulated frequencies in count\n        for (int j = input.length - 1; j >= 0; j--) {\n            int currentInt = input[j];\n            output[count[currentInt] - 1] = currentInt;\n            count[currentInt]--;\n        }\n\n        return output;\n    }"}
{"path":"downloaded/10_46a09331f1a86a98cda3ef08a192502779c94110_Layout_s.java","method_name":"resolveConflict","content":"/**\n \t * end current area if it is the last area of content, add bottom box\n \t * property\n \t * \n \t */\nprivate void resolveConflict( int[] values, int maxTotal, int total,\n \t\t\tint start )\n \t{\n \t\tint length = values.length - start;\n \t\tif ( length == 0 )\n \t\t{\n \t\t\treturn;\n \t\t}\n \t\tassert ( length > 0 );\n \t\tif ( total > maxTotal )\n \t\t{\n \t\t\tint othersTotal = total - values[start];\n \t\t\tif ( values[start] > 0 )\n \t\t\t{\n \t\t\t\tvalues[start] = 0;\n \t\t\t}\n \t\t\tresolveConflict( values, maxTotal, othersTotal, start + 1 );\n \t\t}\n \t}"}
{"path":"downloaded/WaveletWarpingAEig.java","method_name":"ulp1","content":"/**\n   * Returns the rms value of the PS image specified between \n   * the two time indices 228 and 700.\n   */\npublic static double ulp1() {\n    System.out.println(Math.ulp(1.0));\n    return Math.ulp(1.0);\n  }"}
{"path":"downloaded/WaveletWarpingAEig.java","method_name":"dot","content":"/**\n   * Returns the sum of the squared differences between Fa and SGa\n   * if a is an impulse centered at -ka. \n   * @param na the number of inverse wavelet coefficients in a.\n   * @param ka the sample index of a[0].\n   */\nprivate double dot(int itmin, int itmax, float[] x, float[] y) {\n    int nt = x.length;\n    int itlo = itmin;\n    int ithi = itmax; \n    double sum = 0.0;\n    for (int it=itlo; it<=ithi; ++it) \n      sum += x[it]*y[it];\n    return sum;\n  }"}
{"path":"downloaded/WaveletWarpingAEig.java","method_name":"dotPS","content":"/**\n   * Returns the sum of the squared differences between Fa and SGa\n   * if a is an impulse centered at -ka. \n   * @param na the number of inverse wavelet coefficients in a.\n   * @param ka the sample index of a[0].\n   */\nprivate double dotPS(float[] x, float[] y) {\n    int nt = x.length;\n    int itlo = 228;//(_itmin>0)?_itmin:0;\n    int ithi = 700;//(_itmax>0)?_itmax:nt-1;\n    double sum = 0.0;\n    for (int it=itlo; it<=ithi; ++it) \n      sum += x[it]*y[it];\n    return sum;\n  }"}
{"path":"downloaded/WaveletWarpingAEig.java","method_name":"convertFToD","content":"/**\n   * Returns y(t) = h(t)*x(t), where * denotes convolution.\n   */\nprivate double[] convertFToD(float[] f) {\n    int nf = f.length;\n    double[] d = new double[nf];\n    for (int i=0; i<nf; ++i)\n      d[i] = f[i];\n    return d;\n  }"}
{"path":"downloaded/WaveletWarpingAEig.java","method_name":"convertDToF","content":"/**\n   * Returns y(t) = h(t)*x(t), where * denotes convolution.\n   */\nprivate float[][] convertDToF(double[][] d) {\n    int nd2 = d.length;\n    int nd1 = d[0].length;\n    float[][] f = new float[nd2][nd1];\n    for (int i2=0; i2<nd2; ++i2)\n      for (int i1=0; i1<nd1; ++i1)\n        f[i2][i1] = (float) d[i2][i1];\n    return f;\n  }"}
{"path":"downloaded/SqlStatsDao.java","method_name":"getAllRatings","content":"/**\n     * Returns an array of all the reviews in our system\n     * \n     * @return int[] of stars\n     */\npublic int[] getAllRatings() {\n        return new int[] { 1, 3, 5, 3, 4, 2, 4, 3, 2, 1, 2, 5, 1, 1, 2, 5 };\n    }"}
{"path":"downloaded/SqlStatsDao.java","method_name":"getAllPrices","content":"/**\n     * Returns an array of all the reviews in our system\n     * \n     * @return int[] of stars\n     */\npublic double[] getAllPrices() {\n        return new double[] { 99.99, 149.00, 49.00, 89.99, 199.99, 205.00, 299.99, 249.99, 175.00, 309.99, 83.00 };\n    }"}
{"path":"downloaded/WaveletWarpingAEig.java","method_name":"getDiagonal","content":"/**\n   * Rearranges the 2D eigenvalue array and the corresponding 2D eigenvector array,\n   * so that the diagonal of the eigenvalue array is in ascending order.\n   */\nprivate double[] getDiagonal(double[][] eigval) {\n    int n = eigval.length;\n    double[] diag = new double[n];\n    for (int i=0; i<n; ++i) {\n      diag[i] = eigval[i][i];\n    }\n    return diag;\n  }"}
{"path":"downloaded/WaveletWarpingAEig.java","method_name":"isSorted","content":"/**\n   * Rearranges the 2D eigenvalue array and the corresponding 2D eigenvector array,\n   * so that the diagonal of the eigenvalue array is in ascending order.\n   */\nprivate boolean isSorted(double[] x) {\n    int nx = x.length;\n    for (int i=1; i<nx; ++i) {\n      if (x[i]<x[i-1])\n        return false;\n    }\n    return true;\n  }"}
{"path":"downloaded/AccEntityGstServiceImpl.java","method_name":"createCSVrecord","content":"/**\n     * ERP-32829\n     *\n     * @param productTermDetail\n     * @param reqParams\n     * @return\n     */\npublic String createCSVrecord(Object[] listArray) {\n        String rec = \"\";\n        for (int i = 0; i < listArray.length; i++) {\n            rec += \"\\\"\" + (listArray[i] == null ? \"\" : listArray[i].toString().replaceAll(\"\\\"\", \"\")) + \"\\\",\";\n        }\n        return rec;\n    }"}
{"path":"downloaded/HttpTest.java","method_name":"cleanUrlArgs","content":"/**\n     * Do anything that is necessary to clean up the URL args. For example, make\n     * sure any records (represented as an int or long) does not get rendered\n     * using comma separators.\n     * \n     * @param args\n     * @return the clean args\n     */\nprivate static Object[] cleanUrlArgs(Object... args) {\n        for (int i = 0; i < args.length; i++) {\n            Object arg = args[i];\n            if(arg.getClass() == long.class || arg.getClass() == int.class) {\n                args[i] = Long.toString((long) arg);\n            }\n            else if(arg.getClass() == Long.class\n                    || arg.getClass() == Integer.class) {\n                args[i] = arg.toString();\n            }\n        }\n        return args;\n    }"}
{"path":"downloaded/FindMissingNumber.java","method_name":"findOneMissingNumber","content":"/**\n     * in case find one missing number, number is start from 1\n     */\nstatic int findOneMissingNumber(int a[]) {\n        int number = 0;\n        int size = a.length;\n        for (int i = 0; i < size; i++)\n            number ^= ((i + 1) ^ a[i]);\n        number ^= (size + 1);\n        return number;\n    }"}
{"path":"downloaded/WalkingDistance.java","method_name":"rowCombo2Key","content":"/**\n     * Returns integer array of pattern move link set.\n     *\n     * @return integer array of pattern move link set\n     */\nprivate int rowCombo2Key(int[] combo) {\n        int key = 0;\n        for (int i : combo) {\n            key = (key << 3) | i;\n        }\n        return key;\n    }"}
{"path":"downloaded/BlockSaltSlab.java","method_name":"isOpaqueCube","content":"/**\n\t * Is this block (a) opaque and (b) a full 1m cube? This determines whether\n\t * or not to render the shared face of two adjacent blocks and also whether\n\t * the player can attach torches, redstone wire, etc to this block.\n\t */\npublic boolean isOpaqueCube() {\n\t\treturn false;\n\t}"}
{"path":"downloaded/BlockSaltSlab.java","method_name":"renderAsNormalBlock","content":"/**\n\t * If this block doesn't render as an ordinary block it will return False\n\t * (examples: signs, buttons, stairs, etc)\n\t */\npublic boolean renderAsNormalBlock() {\n\t\treturn false;\n\t}"}
{"path":"downloaded/Comparator.java","method_name":"min","content":"/**\n\t * Returns the index of the minimum element of a given array\n\t * @param darray \tDouble Array\n\t * @return\t\t\tInteger index \n\t */\nprivate static double min(Double[] darray){\n\t\tdouble min = darray[0];\n\t\tfor ( double dd : darray){\n\t\t\tmin = Math.min(min,dd);\n\t\t}\n\t\treturn min;\n\t}"}
{"path":"downloaded/Comparator.java","method_name":"max","content":"/**\n\t * Returns the index of the mazimum element of a given array\n\t * @param darray\tDouble Array\n\t * @return\t\t\tInteger Index\n\t */\nprivate static double max(Double[] darray){\n\t\tdouble max = darray[0];\n\t\tfor ( double dd : darray){\n\t\t\tmax = Math.max(max,dd);\n\t\t}\n\t\treturn max;\n\t}"}
{"path":"downloaded/TwitterService.java","method_name":"validateId","content":"/**\n     * check if the tweet id is all digit\n     * @param id\n     */\nprivate void validateId(String id) {\n        if (!id.matches(\"[0-9]+\")) {\n            throw new IllegalArgumentException(\"Invaild Tweet Id\");\n        }\n        return;\n    }"}
{"path":"downloaded/PuzzleProgress.java","method_name":"addScore","content":"/**\n     * Sets a selected hint to a character.\n     *\n     * @return If the character was changed from a previous assignment; i.e. 'corrected' by the user.\n     */\nprivate float addScore(float score, float addition) {\n        addition = Math.max(-1f, Math.min(1f, addition));\n        if (score < 0 && addition < 0) {\n            return score * -addition;\n        }\n        return score * addition;\n    }"}
{"path":"downloaded/CommitCmd.java","method_name":"getName","content":"/**\n     * Create the commit for the configuration\n     *\n     * @param message\n     *        the message of the commit\n     *\n     * @throws RepositoryException\n     *         if the storage directory of the repository not exists\n     *\n     * @throws IOException\n     *         if an I/O error occurs reading from the stream\n     *\n     * @throws ClassNotFoundException\n     *         if class Configuration is not found\n     *\n     * @throws ConfigurationException\n     *         if there are no new files in the index\n     */\npublic String getName() {\n        return \"commit\";\n    }"}
{"path":"downloaded/DayNightController.java","method_name":"resetTimer","content":"/**\n     * Resets the timer for a specified value\n     *\n     * @return the specified value that the timer is reset to.\n     */\nprivate float resetTimer() {\n        final float COUNTDOWNTIME = 10;\n        return COUNTDOWNTIME;\n    }"}
