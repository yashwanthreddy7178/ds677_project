{"path":"downloaded/RandomMarkovChain.java","method_name":"extractAllowedTransitions","content":"/**\n\t * Gets an action to create a random Markov chain based on the specified parameters. <br>\n\t * <br>\n\t *\n\t * The {@code allowedTransitions} matrix has to have the following format, separated by ',':\n\t * <br>\n\t * <table>\n\t * <tr>\n\t * <td></td>\n\t * <td>INITIAL</td>\n\t * <td>foo</td>\n\t * <td>bar</td>\n\t * <td>$</td>\n\t * </tr>\n\t * <tr>\n\t * <td>INITIAL*</td>\n\t * <td>0</td>\n\t * <td>1</td>\n\t * <td>1</td>\n\t * <td>0</td>\n\t * </tr>\n\t * <tr>\n\t * <td>foo</td>\n\t * <td>0</td>\n\t * <td>1</td>\n\t * <td>0</td>\n\t * <td>1</td>\n\t * </tr>\n\t * <tr>\n\t * <td>bar</td>\n\t * <td>0</td>\n\t * <td>0</td>\n\t * <td>1</td>\n\t * <td>1</td>\n\t * </tr>\n\t * </table>\n\t *\n\t * @param allowedTransitionsFilePath\n\t *            Holds the allowed transitions from each state to each other (1=allowed, 0=not\n\t *            allowed).\n\t * @param averageThinkTimeMs\n\t *            The average think time to be used. Will be multiplied with a random factor between\n\t *            0.5 and 1.5 for each transition.\n\t * @param outputDataHolder\n\t *            The data holder that will hold the created Markov chain.\n\t * @return The action to be used for creating the Markov chain.\n\t */\nprivate int[][] extractAllowedTransitions(String[][] template) {\n\t\tint[][] allowedTransitions = new int[template.length - 1][template[0].length - 1];\n\n\t\tfor (int row = 0; row < allowedTransitions.length; row++) {\n\t\t\tfor (int col = 0; col < allowedTransitions[0].length; col++) {\n\t\t\t\tallowedTransitions[row][col] = Integer.parseInt(template[row + 1][col + 1]);\n\t\t\t}\n\t\t}\n\n\t\treturn allowedTransitions;\n\t}"} {"path":"downloaded/Invoker.java","method_name":"isExpectedException","content":"/**\n   * @param ite The exception that was just thrown\n   * @param expectedExceptions The list of expected exceptions for this\n   * test method\n   * @return true if the exception that was just thrown is part of the\n   * expected exceptions\n   */\nprivate boolean isExpectedException(Throwable ite, Class<?>[] exceptions) {\n    if(null == exceptions) {\n      return false;\n    }\n\n    Class<?> realExceptionClass= ite.getClass();\n\n    for(int i= 0; i < exceptions.length; i++) {\n      if(exceptions[i].isAssignableFrom(realExceptionClass)) {\n        return true;\n      }\n    }\n\n    return false;\n  }"} {"path":"downloaded/ConstantInfo.java","method_name":"hasPriority","content":"/**\n     * The index of this constant in the constant pool. Is -1 if the\n     * index has not yet been resolved. Constant pool indexes are resolved\n     * when the constant pool is written out.\n     */\nboolean hasPriority() {\n        return false;\n    }"} {"path":"downloaded/ConstantInfo.java","method_name":"getEntryCount","content":"/**\n     * The index of this constant in the constant pool. Is -1 if the\n     * index has not yet been resolved. Constant pool indexes are resolved\n     * when the constant pool is written out.\n     */\nint getEntryCount() {\n        return 1;\n    }"} {"path":"downloaded/ModelObject.java","method_name":"validateModel","content":"/**\n     *\n     */\npublic boolean validateModel(){\n        System.out.println(\"Validated!\");\n        return true;\n    }"}