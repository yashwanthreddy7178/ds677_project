{"path":"downloaded/RandomMarkovChain.java","method_name":"extractAllowedTransitions","content":"/**\n\t * Gets an action to create a random Markov chain based on the specified parameters. <br>\n\t * <br>\n\t *\n\t * The {@code allowedTransitions} matrix has to have the following format, separated by ',':\n\t * <br>\n\t * <table>\n\t * <tr>\n\t * <td></td>\n\t * <td>INITIAL</td>\n\t * <td>foo</td>\n\t * <td>bar</td>\n\t * <td>$</td>\n\t * </tr>\n\t * <tr>\n\t * <td>INITIAL*</td>\n\t * <td>0</td>\n\t * <td>1</td>\n\t * <td>1</td>\n\t * <td>0</td>\n\t * </tr>\n\t * <tr>\n\t * <td>foo</td>\n\t * <td>0</td>\n\t * <td>1</td>\n\t * <td>0</td>\n\t * <td>1</td>\n\t * </tr>\n\t * <tr>\n\t * <td>bar</td>\n\t * <td>0</td>\n\t * <td>0</td>\n\t * <td>1</td>\n\t * <td>1</td>\n\t * </tr>\n\t * </table>\n\t *\n\t * @param allowedTransitionsFilePath\n\t *            Holds the allowed transitions from each state to each other (1=allowed, 0=not\n\t *            allowed).\n\t * @param averageThinkTimeMs\n\t *            The average think time to be used. Will be multiplied with a random factor between\n\t *            0.5 and 1.5 for each transition.\n\t * @param outputDataHolder\n\t *            The data holder that will hold the created Markov chain.\n\t * @return The action to be used for creating the Markov chain.\n\t */\nprivate int[][] extractAllowedTransitions(String[][] template) {\n\t\tint[][] allowedTransitions = new int[template.length - 1][template[0].length - 1];\n\n\t\tfor (int row = 0; row < allowedTransitions.length; row++) {\n\t\t\tfor (int col = 0; col < allowedTransitions[0].length; col++) {\n\t\t\t\tallowedTransitions[row][col] = Integer.parseInt(template[row + 1][col + 1]);\n\t\t\t}\n\t\t}\n\n\t\treturn allowedTransitions;\n\t}"}
{"path":"downloaded/Invoker.java","method_name":"isExpectedException","content":"/**\n   * @param ite The exception that was just thrown\n   * @param expectedExceptions The list of expected exceptions for this\n   * test method\n   * @return true if the exception that was just thrown is part of the\n   * expected exceptions\n   */\nprivate boolean isExpectedException(Throwable ite, Class<?>[] exceptions) {\n    if(null == exceptions) {\n      return false;\n    }\n\n    Class<?> realExceptionClass= ite.getClass();\n\n    for(int i= 0; i < exceptions.length; i++) {\n      if(exceptions[i].isAssignableFrom(realExceptionClass)) {\n        return true;\n      }\n    }\n\n    return false;\n  }"}
{"path":"downloaded/ConstantInfo.java","method_name":"hasPriority","content":"/**\n     * The index of this constant in the constant pool. Is -1 if the\n     * index has not yet been resolved. Constant pool indexes are resolved\n     * when the constant pool is written out.\n     */\nboolean hasPriority() {\n        return false;\n    }"}
{"path":"downloaded/ConstantInfo.java","method_name":"getEntryCount","content":"/**\n     * The index of this constant in the constant pool. Is -1 if the\n     * index has not yet been resolved. Constant pool indexes are resolved\n     * when the constant pool is written out.\n     */\nint getEntryCount() {\n        return 1;\n    }"}
{"path":"downloaded/ModelObject.java","method_name":"validateModel","content":"/**\n     *\n     */\npublic boolean validateModel(){\n        System.out.println(\"Validated!\");\n        return true;\n    }"}
{"path":"downloaded/HRServiceAppModuleImpl.java","method_name":"validateDepartment","content":"/**\n     * Container's getter for EmpDeptFkLink1.\n     * @return EmpDeptFkLink1\n     */\npublic String validateDepartment(){\n        \n        return \"continue\";\n    }"}
{"path":"downloaded/HRServiceAppModuleImpl.java","method_name":"testAction","content":"/**\n     * Container's getter for EmpDeptFkLink1.\n     * @return EmpDeptFkLink1\n     */\npublic String testAction(String arg){\n        \n        return \"continue\";\n    }"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getCollaborationRel","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getCollaborationRel(String viewname, String mainauth, String collabAuth, int start, int end) {\n\t\tString part1= \"SELECT a.author as author, coa.author as collabauth, COUNT(coa.author) as collabcnt FROM \" +\n\t\t\t\t\"dblp_author_ref_new a, dblp_author_ref_new coa, \"+ viewname + \" as p \" +\n\t\t\t\t\"WHERE a.id = coa.id AND a.id = p.id AND a.author != coa.author AND p.year >= \" + start + \" AND p.year <= \" + end;\n\t\tString part2=\"\";\n\t\tif (mainauth != null && !mainauth.equals(\"\")) {\n\t\t\tString str= \" AND a.author like \\\"\"+mainauth+\"\\\"\";\n\t\t\tif (collabAuth != null && !collabAuth.equals(\"\"))\n\t\t\t\tstr += \" AND coa.author like \\\"\"+collabAuth+\"\\\"\";\n\t\t\tpart2=str;\n\t\t}\n\t\tString coauthRelSQL= part1 + part2 + \" GROUP BY a.author, coa.author\";\n\t\treturn coauthRelSQL;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getCollabRelTableCreationSQL","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getCollabRelTableCreationSQL(String domainName) {\n\t\tString crCollabTableSQL = \"CREATE TABLE IF NOT EXISTS dblp_collab_\" +domainName +\n\t\t\"(author varchar(70) NOT NULL, \" +\n\t\t\" collabauth varchar(70) NOT NULL, \" + \n\t\t\" collabcnt int NOT NULL, \" +\n\t\t\" PRIMARY KEY (author,collabauth)) \";\n\t\treturn crCollabTableSQL;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getOldAuthorsInTimeSlice","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getOldAuthorsInTimeSlice(String viewname, int start, int end) {\n\t\tString sql = \"create table tmpt select ca from \" +\n\t\t\t\t\"(select distinct author as ca from dblp_author_ref_new a, \"+ viewname + \" as p \" +\n\t\t\t\t\"where a.id = p.id and p.year >= \" + start + \" and p.year <= \" + end + \") as currauths, \" +\n\t\t\t\t\"(select distinct author as pa from dblp_author_ref_new a, \"+ viewname + \" as p \" +\n\t\t\t\t\"where a.id = p.id and  p.year <= \" + (start -1) +\") as pastauths \" +\n\t\t\t\t\"where currauths.ca = pastauths.pa\";\n\t\treturn sql;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getOldOldCollaboration","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getOldOldCollaboration(String viewname, int start, int end) {\n\t\tString part1 = \"SELECT a.author as author, coa.author as collabauth, COUNT(*) as collabcnt \" +\n\t\t\t\t\"FROM dblp_author_ref_new a, dblp_author_ref_new coa, tmpt t1, tmpt t2, \" + viewname + \" as p \" +\n\t\t\t\t\"WHERE a.id = coa.id AND a.id = p.id AND a.author != coa.author AND a.author = t1.ca \" +\n\t\t\t\t\"AND coa.author = t2.ca AND p.year >= \" + start + \" AND p.year <= \" + end ;\n\t\t\n\t\tString coauthRelSQL= part1 + \" GROUP BY a.author, coa.author\";\n\t\treturn coauthRelSQL;\n\t}"}
{"path":"downloaded/DBLPSQLs.java","method_name":"getTopicTableCreationSQL","content":"/**\n\t * @param mainauth - The specific author, for which we are looking its collaborating authors. If null or \"\", it means for all authors\n\t * @param collabAuth - The specific collaborating author who has collaborated with main author. If null, look for all collaborators\n\t * @param start - start of time period\n\t * @param end - end of time period\n\t * @return the SQL string that returns author, collabAuthor, collabCount\n\t * Note that mainauth = null and collabAuth not null- does not make a valid query\n\t */\npublic static final String getTopicTableCreationSQL(String shortname) {\n\t\tString crTopicTableSQL = \"CREATE TABLE IF NOT EXISTS dblp_topic_\" +shortname +\n\t\t\"(tid varchar(50) NOT NULL, \" +\n\t\t\" keyword varchar(255) NOT NULL, \" + \n\t\t\" istop tinyint UNSIGNED ZEROFILL, \" + // Is this keyword a top keyword for this topic\n\t\t\" PRIMARY KEY (tid,keyword)) \";\n\t\treturn crTopicTableSQL;\n\t}"}
{"path":"downloaded/RocketPerformance.java","method_name":"formatDouble","content":"/*************\n    * formatDouble method\n    *    -This method takes a double as a parameter and returns a double with two decimals.\n    *    @param   double to be truncated\n    *    @return  double that has been truncated\n    ****************/\nprivate double formatDouble(double number){\n      return Double.parseDouble(String.format(\"%.2f\", number));\n   }"}
{"path":"downloaded/Critter.java","method_name":"getcoor","content":"/**\n\t * A 25% chance to mutate once by calling the helper method, 6.25% to mutate\n\t * twice, etc.\n\t */\nprivate int[] getcoor(int direction) {\n\t\tint[] temp = new int[2];\n\t\tdirection = (direction % 6 + 6) % 6;\n\t\tswitch (direction) {\n\t\tcase 0:\n\t\t\ttemp[0] = 0;\n\t\t\ttemp[1] = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttemp[0] = 1;\n\t\t\ttemp[1] = 1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttemp[0] = 1;\n\t\t\ttemp[1] = 0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\ttemp[0] = 0;\n\t\t\ttemp[1] = -1;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ttemp[0] = -1;\n\t\t\ttemp[1] = -1;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\ttemp[0] = -1;\n\t\t\ttemp[1] = 0;\n\t\t\tbreak;\n\t\t}\n\t\treturn temp;\n\t}"}
{"path":"downloaded/Geodes.java","method_name":"escapeOql","content":"/**\n   * Replace single quote {@code '} with two quotes {@code ''}\n   *\n   * <p>From <a href=\"https://www.postgresql.org/docs/9.1/sql-syntax-lexical.html\">SQL syntax in PostgreSQL</a>:\n   *  <pre>\n   *    To include the escape character in the identifier literally, write it twice.\n   *  </pre>\n   * </p>\n   * @param oql string to escape\n   * @return escaped string\n   * @see\n   */\nstatic String escapeOql(CharSequence oql) {\n    return oql.toString().replace(\"'\", \"''\");\n  }"}
{"path":"downloaded/CocosHelper.java","method_name":"getSafeArea","content":"/**\n     * Battery receiver to getting battery level.\n     */\npublic static float[] getSafeArea() {\n        return new float[]{0, 0, 0, 0};\n    }"}
{"path":"downloaded/Use.java","method_name":"getDescription","content":"/**\n\t * Returns the purpose of the use command\n\t * \n\t * @return String of the purpose of the use command\n\t */\npublic String getDescription() {return \"Use an item in your inventory\"; }"}
{"path":"downloaded/EpaDataAgent.java","method_name":"getName","content":"/**\n\t * @param args\n\t */\npublic String getName() {\n\t\treturn \"Environmental Protection Agency\";\n\t}"}
{"path":"downloaded/EditDistanceProblem.java","method_name":"diff","content":"/**\n   * Return the the cost of the difference between the two characters.\n   *\n   * @param a The first character\n   * @param b The second character\n   */\npublic int diff(char a, char b) {\n    return (a == b ? 0 : 1);\n  }"}
{"path":"downloaded/ClassLoaderUtil.java","method_name":"getInnerClass","content":"/**\n     *Retrieves a given inner class definition from the specified outer class.\n     *@param cls the outer Class\n     *@param innerClassName the fully-qualified name of the inner class of interest\n     */\nprivate static Class getInnerClass(Class cls, String innerClassName) {\n        Class result = null;\n        Class[] innerClasses = cls.getDeclaredClasses();\n        for (Class c : innerClasses) {\n            if (c.getName().equals(innerClassName)) {\n                result = c;\n                break;\n            }\n        }\n        return result;\n    }"}
{"path":"downloaded/Oculta.java","method_name":"toBinary","content":"/**\n     * Toma un caracter(un numero en este caso) y lo transforma en su representacion\n     * en binario\n     * @param un byte que es el caractera a transformar.\n     * @return la representacion en cadena binaria.\n     */\nprivate String toBinary(byte caracter){\n        byte byteDeCaracter = (byte)caracter;\n        String binario=\"\";\n        for( int i = 7; i>=0; i--){\n            binario += ( ( ( byteDeCaracter & ( 1<<i ) ) > 0 ) ? \"1\" : \"0\" ) ;\n        }\n        return binario;\n    }"}
{"path":"downloaded/Oculta.java","method_name":"formato","content":"/**\n     * Toma una cadena con espacios y la regresa completa, rellena de ceros \n     * @param una cadena en \"binario\".\n     * @return la misma cadena pero rellena de ceros.\n     */\nprivate String formato(String cadena){\n        cadena = cadena.replaceAll(\" \",\"0\");\n        return cadena;\n    }"}
{"path":"downloaded/EventActionInfo.java","method_name":"validate","content":"/**\n      * Title: validate\n      * Description: Description of the method\n      * \n      */\npublic boolean validate() throws Exception {\n        return true;\n    }"}
{"path":"downloaded/TwitterService.java","method_name":"validateId","content":"/**\n     * check if the tweet id is all digit\n     * @param id\n     */\nprivate void validateId(String id) {\n        if (!id.matches(\"[0-9]+\")) {\n            throw new IllegalArgumentException(\"Invaild Tweet Id\");\n        }\n        return;\n    }"}
{"path":"downloaded/DayNightController.java","method_name":"resetTimer","content":"/**\n     * Resets the timer for a specified value\n     *\n     * @return the specified value that the timer is reset to.\n     */\nprivate float resetTimer() {\n        final float COUNTDOWNTIME = 10;\n        return COUNTDOWNTIME;\n    }"}
